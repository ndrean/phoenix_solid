defmodule PhxSolidWeb.GController do
  use PhxSolidWeb, :controller
  alias PhxSolid.SocialUser
  require Logger

  action_fallback PhxSolidWeb.LoginErrorController

  def redirect_if_bad_state(conn, state) do
    g_state = fetch_session(conn) |> get_session(:g_state)

    if g_state !== state do
      conn
      |> put_flash(:error, "Bad state / corrupted Google Login response")
      |> Plug.Conn.put_status(401)
      |> redirect(to: ~p"/")
    else
      conn
    end
  end

  @doc """
  Given the code returned by Google when he detects a user in his session
  and the "state token" generated by the backend to mitigate the data received, we
  run a 3 steps process:

  - anti-forgery state token check against the value saved in the session
  <https://developers.google.com/identity/openid-connect/openid-connect#createxsrftoken>

  - ID_token verfication against Google JWK, plus ISS and AUD check
  <https://developers.google.com/identity/openid-connect/openid-connect#validatinganidtoken>

  - Validate ISS and AUD
  <https://developers.google.com/identity/openid-connect/openid-connect#validatinganidtoken>

  """
  def login(conn, %{"code" => code, "state" => state} = _params) do
    redirect_if_bad_state(conn, state)

    g_oauth_redirect_url =
      fetch_session(conn) |> get_session(:g_oauth_redirect_url)

    with {:ok, profile} <- ElixirGoogleAuth.get_checked_profile(g_oauth_redirect_url, code),
         true <-
           ElixirGoogleCerts.check_iss(profile["iss"]) &&
             ElixirGoogleCerts.check_user(profile["aud"], profile["azd"]) do
      profile =
        for {key, val} <- profile,
            into: %{},
            do: {String.to_atom(key), val}

      case SocialUser.create(%{email: profile.email, name: profile.name, user_token: "0"}) do
        {:error, errors} ->
          conn
          |> fetch_session()
          |> fetch_flash()
          |> put_flash(:error, inspect(errors))
          |> redirect(to: ~p"/")

        {:ok, user} ->
          token = PhxSolid.Token.user_generate(profile.email)
          {:ok, u} = SocialUser.update_token(%{id: user.id, user_token: token})

          conn
          |> fetch_session()
          |> put_session(:user_token, token)
          |> put_session(:profile, profile)
          |> put_session(:logs, u.logs)
          |> put_session(:origin, "google_backend_signin")
          |> redirect(to: ~p"/welcome")
      end
    end
  end

  def handle(conn, params) do
    params |> dbg()
    conn
  end
end
