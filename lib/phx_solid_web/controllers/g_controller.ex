defmodule PhxSolidWeb.GController do
  use PhxSolidWeb, :controller
  # alias PhxSolidWeb.UserSessionController
  alias PhxSolid.SocialUser
  alias PhxSolid.Accounts.User
  require Logger

  @doc """
  Plug to check the state
  """
  def redirect_if_bad_state(conn, _opts) do
    g_state =
      fetch_session(conn)
      |> get_session(:g_state)

    state =
      Map.get(conn.params, "state")

    # Plug.Conn.fetch_query_params(conn)
    # |> Map.get(:params)
    # |> Map.get("state")

    if g_state !== state do
      conn
      |> put_flash(:error, "Bad state / corrupted Google Login response")
      |> redirect(to: ~p"/")
      |> halt()
    else
      conn
    end
  end

  @doc """
  Given the code returned by Google when he detects a user in his session
  and the "state token" generated by the backend to mitigate the data received, we
  run a 3 steps process:

  - anti-forgery state token check by the Plug `:redirect_if_bad_state` against the value saved in the session
  <https://developers.google.com/identity/openid-connect/openid-connect#createxsrftoken>

  - ID_token verfication against Google JWK, plus ISS and AUD check
  <https://developers.google.com/identity/openid-connect/openid-connect#validatinganidtoken>

  - Validate ISS and AUD
  <https://developers.google.com/identity/openid-connect/openid-connect#validatinganidtoken>

  """
  plug :redirect_if_bad_state

  # TRIAL TO CONNECT TO THE "OFFICIAL" auth process
  # def login(conn %{"code"=> code}) do
  #   with {:ok, profile} <-
  #     ElixirGoogleAuth.get_checked_profile(PhxSolid.g_oauth_redirect_url(), code),
  #   true <-
  #     ElixirGoogleCerts.check_iss(profile.iss) &&
  #       ElixirGoogleCerts.check_user(profile.aud, profile.azp) do
  #         PhxSolidWeb.UserSessionController.create(conn, )
  #       end
  # end

  def login(conn, %{"code" => code}) do
    with {:ok, profile} <-
           ElixirGoogleAuth.get_checked_profile(PhxSolid.g_oauth_redirect_url(), code),
         true <-
           ElixirGoogleCerts.check_iss(profile.iss) &&
             ElixirGoogleCerts.check_user(profile.aud, profile.azp),
         {:ok, %User{} = user} <-
           SocialUser.create(%{email: profile.email, name: profile.name, user_token: "0"}) do
      token = PhxSolid.Token.user_generate(profile.email)
      {:ok, u} = SocialUser.update_token(%{id: user.id, user_token: token})

      conn
      |> fetch_session()
      |> put_session(:user_token, token)
      |> put_session(:profile, profile)
      |> put_session(:logs, u.logs)
      |> put_session(:origin, "google_backend_signin")
      |> redirect(to: ~p"/welcome")
    else
      false ->
        redirect(conn, to: ~p"/")

      {:error, reason} ->
        Logger.warning("handle Login Err____________#{inspect(reason)}")

        conn
        |> Phoenix.Controller.put_flash(:error, inspect(reason["error_description"]))
        |> redirect(to: ~p"/")
    end
  end
end
