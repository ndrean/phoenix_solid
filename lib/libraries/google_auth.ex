defmodule ElixirGoogleAuth do
  @moduledoc """
  Google OAuth Authentication for Elixir Apps.

  It exposes two functions, `generate_oauth_url/1` and `get_checked_profile/1`.

  The function `generate_oauth_url/1` takes a token and builds a URL to reach a Google endpoint.

  The function `get_checked_profile/1` takes a "code" received from Google
  and checks for the users' profile using cryptography.

  ### How to use this package

  You define a link as a "Google Login" (an image or SVG for example). The link routes to a controller.
  Your "GET" endpoint is defined in your router and you pass it to Google, via the "config.exs" as shown below.

  > This endpoint is also declared in the project set up in the Google library API

  When you click on the link, you get a form which is prefilled if you have an active Google session.
  If not, you will get a Google SignIn form.

  The Google docs describes a three-step process to secure the transction: anti-CSRF with a token,
  decipher a code via a PEM or JWK and two other checks.

  To mitigate CSRF, you generate a token, save it and pass it to Google.
  The token can be generated by `Phoenix.token`. If you use another method like below,
  it must be saved in the `Plug.Session.Store` because the Google redirection halts the request.

  ```
  Base.url_encode64(:crypto.strong_rand_bytes(32))
  ```

  When you receive a response from Google, you use a "token checker" plug function,
  say `redirect_if_bad_state(conn, state)`. This function checks if the received `state`
  extracted from the params is equal to the state saved in the session (or `Phoenix.Token.verify`).
  Redirect if not, else pass on the `conn`.

  The function `get_checked_profile/1` takes the access-token received from Google.
  We then decipher and perform checks. We use two functions from library `ElixirGoogleCerts.check_iss`
  and `ElixirGoogleCerts.check_user`.


  ### An example:

      # GET /my_ctrl_path :login
      def login(conn, %{"code" => code, "state" => state} = _params) do
        redirect_if_bad_state(conn, state)

        with {:ok, profile} <- ElixirGoogleAuth.get_checked_profile(code),
            true <-
              ElixirGoogleCerts.check_iss(profile["iss"]) &&
                ElixirGoogleCerts.check_user(profile["aud"], profile["azd"]) do
          profile =
            for {key, val} <- profile,
                into: %{},
                do: {String.to_atom(key), val}
          ...save to database and redirect
      end

      def redirect_if_bad_state(conn, state) do
        g_state = fetch_session(conn) |> get_session(:g_state)

        if g_state !== state do
          conn
          |> put_flash(:error, "Bad state / corrupted Google Login response")
          |> Plug.Conn.put_status(401)
          |> redirect(to: ~p"/")
        else
          conn
        end
      end

      # HTML
      <.link href={@g_oauth_url}>
        <span>Sign in with Google</span>
      </.link>


  ### Dependencies

      Mix.install([{:jason, "~> 1.4"},{:joken, "~> 2.5"}, {:elixir_g_certs, "~> 0.1"}])

  ### Set up:

  Env. variables: you need to set up a project in the [Google API library](https://console.cloud.google.com/apis/library).

      GOOGLE_CLIENT_ID
      GOOGLE_CLIENT_SECRET


  Configure the path to the controller in "config.exs" or as env. variable.

      config :my_app, :g_auth_ctrl_path, "my_ctrl_path"
      # or env. variable
      G_AUTH_CTRL_PATH

  """

  @g_auth_base_url "https://accounts.google.com/o/oauth2/v2/auth?"
  @g_token_url "https://oauth2.googleapis.com/token"
  @scope "openid profile email"

  @doc """
  Creates the Google OAuth2 URL with "client_id", "scope" and "redirect_uri".
  This is the URL you need to inject in your "Login with Google" button.
  """
  def generate_oauth_url(state) do
    url_with_query_string(
      @g_auth_base_url,
      %{
        response_type: "code",
        client_id: google_client_id(),
        scope: @scope,
        include_granted_scopes: true,
        prompt: "consent",
        access_type: "offline",
        redirect_uri: redirect_uri(),
        state: state
      }
    )
  end

  @doc """
  Get verified user profile from the code by using Google JWK.
  """
  def get_checked_profile(code) do
    body =
      Jason.encode!(%{
        client_id: google_client_id(),
        client_secret: google_client_secret(),
        redirect_uri: redirect_uri(),
        grant_type: "authorization_code",
        code: code
      })

    with {:ok, %{"id_token" => jwt} = _body} <- http_post(@g_token_url, body),
         {:ok, profile} <- ElixirGoogleCerts.check_identity_v1(jwt) do
      {:ok, profile}
    else
      {:error, reason} -> {:error, reason}
    end
  end

  ##### Helpers ########

  @doc """
  Post request, uses `:httpc` to remove dependencies
  """
  def http_post(url, body) do
    case :httpc.request(:post, {~c"#{url}", [], ~c"application/json", body}, [], []) do
      {:ok, {{_, 200, _}, _headers, body}} ->
        {:ok, Jason.decode!(body)}

      {:error, reason} ->
        {:error, reason}
    end
  end

  @doc """
  Helper to generate a full URL with query strings
  """
  def url_with_query_string(base, query_map) do
    base
    |> URI.new!()
    |> URI.append_query(URI.encode_query(query_map))
    |> URI.to_string()
  end

  @doc """
  `The full path to the controller.
  """
  def redirect_uri() do
    Path.join(PhxSolidWeb.Endpoint.url(), auth_ctrl_path())
  end

  def google_client_id do
    System.get_env("GOOGLE_CLIENT_ID")
  end

  def google_client_secret do
    System.get_env("GOOGLE_CLIENT_SECRET")
  end

  def auth_ctrl_path() do
    System.get_env("G_AUTH_CTRL_PATH") ||
      Application.get_application(__MODULE__)
      |> Application.get_env(:g_auth_ctrl_path)
  end
end
