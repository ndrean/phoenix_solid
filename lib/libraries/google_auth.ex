defmodule ElixirGoogleAuth do
  @moduledoc """
  Google OAuth Authentication for Elixir Apps.

  It exposes two functions, `generate_oauth_url/3` and `get_checked_profile/2`.

  The function `generate_oauth_url/2` takes the URL of you endpoint to which you want Google to
  send a response, a token named "state", and  options you want to pass sa a _Map_ (e.g. `%{hl: "es"}`).
  It builds the URL where you will reach Google and submit your credentials.

  The function `get_checked_profile/2` takes the previous URL and the "code" received from Google. It makes
  a POST request to a Google endpoint and receives an ID_token that eventually gives the users' profile.

  ### How to use this package

  1) You define a HTML link as say "Google Login". The link routes to the endpoint you
  build using `generate_oauth_url/2`.

  2) In the controller that renders this login link, you build a secured token.
  The token can be generated by `Phoenix.token`. If you use another method like below,
  it must be saved in the `Plug.Session.Store` because the Google redirection halts the request.

  ```
  Base.url_encode64(:crypto.strong_rand_bytes(32))
  ```


  3) Your "GET" endpoint is defined in your _router_ and you declare it via the "config.exs" or env. variable
  as shown further below.

  > This endpoint is also declared in the project set up in the Google library API


  4) When you trigger the link, you get a form. If you have an active Google session, Google will prefill it.
  If not, you will get a Google SignIn form. If for example you passed the option `%{hl: "es"}`, then the form
  will appear in Spanish even if your account is from a non-spanish speaking country.

  Once you submit the form, Google will send a code to your defined URL. The controller receives data in the params.

  The Google docs describes a three-step process to secure the transaction: anti-CSRF with a token,
  decipher a code via a PEM or JWK and two other checks.

  5) You receive a response from Google in your params with the keys "code" and "state".
  You firstly use a "token checker" plug function, say `redirect_if_bad_state(conn, state)`.
  This function checks if the received `state` extracted from the params is equal to the state saved
  in the session (or via a `Phoenix.Token.verify` if you used this). Redirect if not, else continue.

  6) You invoke `get_checked_profile/2`. It takes the "code" received from Google and your URL.
  It will decipher the code against Google's public keys (PEM or JWK).
  7) It will remain to perform checks. We use two functions from library `ElixirGoogleCerts.check_iss`
  and `ElixirGoogleCerts.check_user`.


  ### An example:

      # GET /my_ctrl_path :login
      def login(conn, %{"code" => code, "state" => state} = _params) do
        redirect_if_bad_state(conn, state)

        g_oauth_redirect_url =
          fetch_session(conn)|> get_session(:g_oauth_redirect_url)

        with {:ok, profile} <- ElixirGoogleAuth.get_checked_profile(g_oauth_redirect_url, code),
            true <-
              ElixirGoogleCerts.check_iss(profile["iss"]) &&
                ElixirGoogleCerts.check_user(profile["aud"], profile["azd"]) do
          profile =
            for {key, val} <- profile,
                into: %{},
                do: {String.to_atom(key), val}
          ...save to database and redirect
      end

      def redirect_if_bad_state(conn, state) do
        g_state = fetch_session(conn) |> get_session(:g_state)

        if g_state !== state do
          conn
          |> put_flash(:error, "Bad state / corrupted Google Login response")
          |> Plug.Conn.put_status(401)
          |> redirect(to: ~p"/")
        else
          conn
        end
      end

      #####
      # HTML generate from your "home" page
      <.link href={@g_oauth_url}>
        <span>Sign in with Google</span>
      </.link>

      ### HomeController.ex
      def home(conn, _) do
        g_oauth_redirect_url =
          Path.join(
            MyApp.Endpoint.url(),
            Application.get_application(__MODULE__) |> Application.get_env(:g_auth_ctrl_path)
          )
        g_state = Base.url_encode64(:crypto.strong_rand_bytes(32))
        g_oauth_url = ElixirGoogleAuth.generate_oauth_url(g_oauth_redirect_url, g_state)

        conn
        |> fetch_session()
        |> put_session(:g_oauth_redirect_url, g_oauth_redirect_url)
        |> put_session(:g_state, g_state)
        |> assign(:g_oauth_url, g_oauth_url)
        ...
      end


  ### Dependencies

      Mix.install([{:jason, "~> 1.4"},{:joken, "~> 2.5"}, {:elixir_g_certs, "~> 0.1"}])

  ### Set up:

  Env. variables: you need to set up a project in the [Google API library](https://console.cloud.google.com/apis/library).

      GOOGLE_CLIENT_ID
      GOOGLE_CLIENT_SECRET


  Configure the path to the controller in "config.exs" or as env. variable.

      config :my_app, :g_auth_ctrl_path, "my_ctrl_path"
      # or env. variable
      G_AUTH_CTRL_PATH

  Configure the headers

      def g_login(conn, _) do
        Plug.Conn.put_resp_header(
          conn,
          "cross-origin-opener-policy",
          "same-origin-allow-popups"
        )
      end

  In the `pipeline :browser`, add `plug :g_login`

  """

  @g_auth_base_url "https://accounts.google.com/o/oauth2/v2/auth?"
  @g_token_url "https://oauth2.googleapis.com/token"
  @scope "openid profile email"

  @doc """
  Creates the Google OAuth2 URL with "client_id", "scope" and "redirect_uri".
  This is the URL you need to inject in your "Login with Google" button.
  """
  def generate_oauth_url(aouth_redirect_url, state, opts \\ %{}) do
    url_with_query_string(
      @g_auth_base_url,
      %{
        response_type: "code",
        client_id: google_client_id(),
        scope: @scope,
        include_granted_scopes: true,
        prompt: "consent",
        access_type: "offline",
        redirect_uri: aouth_redirect_url,
        state: state
      }
      |> Map.merge(opts)
    )
  end

  @doc """
  Get verified user profile from the code by using Google JWK.
  """
  def get_checked_profile(aouth_redirect_uri, code) do
    body =
      Jason.encode!(%{
        client_id: google_client_id(),
        client_secret: google_client_secret(),
        redirect_uri: aouth_redirect_uri,
        grant_type: "authorization_code",
        code: code
      })

    with {:ok, %{"id_token" => jwt} = _body} <- http_post(@g_token_url, body),
         {:ok, profile} <- ElixirGoogleCerts.check_identity_v1(jwt) do
      {:ok, profile}
    else
      {:error, reason} -> {:error, reason}
    end
  end

  ##### Helpers ########

  @doc """
  Post request, uses `:httpc` to remove dependencies
  """
  def http_post(url, body) do
    case :httpc.request(:post, {~c"#{url}", [], ~c"application/json", body}, [], []) do
      {:ok, {{_, 200, _}, _headers, body}} ->
        {:ok, Jason.decode!(body)}

      # {:ok, Jsonrs.decode!(body)}

      {:error, reason} ->
        {:error, reason}
    end
  end

  @doc """
  Helper to generate a full URL with query strings
  """
  def url_with_query_string(base, query_map) do
    base
    |> URI.new!()
    |> URI.append_query(URI.encode_query(query_map))
    |> URI.to_string()
  end

  def google_client_id do
    System.get_env("GOOGLE_CLIENT_ID")
  end

  def google_client_secret do
    System.get_env("GOOGLE_CLIENT_SECRET")
  end

  def auth_ctrl_path() do
    System.get_env("G_AUTH_CTRL_PATH") ||
      Application.get_application(__MODULE__)
      |> Application.get_env(:g_auth_ctrl_path)
  end
end
